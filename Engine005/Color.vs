/////////////////////////
// FileName : Color.vs
////////////////////////

//Color.vs 는 픽셀에 대한 Vertex Shader 이므로 .vs 이다.

//Color.vs, Color.ps 로 작성하는 파일은 HLSL 문법으로 작성된 소스들이라고 보면 된다.
//HLSL 이라는 것은 3D처럼 보여줄 수 있는 말 그대로 셰이더를 호출하고 객체를 그리기 위한 그래픽적 문법을 말하는 듯 하다
//따라서 vs, ps 프로그램은 셰이더 프로그램이다 라고 생각하자

//우선 전역변수부터 선언한다..
//일단 모든 전역변수는 cbuffer 라고 하는 버퍼 객체 타입에 넣어야 한다.
//논리적으로 이 버퍼들을 조작하는 일은 셰이더의 효율적인 실행뿐만 아니라,
//그래픽카드가 어떻게 이 버퍼들을 저장하는지와도 관련되어있기 때문에 아주 중요하다..
//우선 앞서 구현했었던 월드 매트릭스(씬 전체에 대한), 뷰 매트릭스(카메라에 대한), 투영 매트릭스(2D UI에 대한) 3가지를 넣어준다
//왜냐하면, 이 행렬들은 매 프레임마다 계산되어 업데이트되므로 같은 버퍼에 넣어주는 것
//행렬들에 대한 구체적인 연산은 선형대수학이 중요해지는 부분이다..

//인덱스 버퍼 -> 한개의 오브젝트가 갖고있는 Vertex 들이 연결되는 순서를 기록하는 버퍼이고, 책의 목차와도 같다. 비디오 메모리에서의 캐싱 가능성을 높여주므로
//성능 측면에서도 사용 권장되는 버퍼

//정점 셰이더(Vertex Shaders) -> 말 그대로, Vertex 들을 (폴리곤을 이루는 점, 정점이라고 많이 표현하는듯 하다) 3D 공간에 그려주기 위한 작은 프로그램이라고 봐도 무방하다
//결국 그냥 버퍼에 있는 Vertex 들을 3D 공간으로 변환시켜주는 작업을 하는것.
//하지만 모든것은 3D 공간을 표현하기 위해 셰이더를 거쳐서 그릴 수 밖에 없으므로 백 버퍼, 각 매트릭스들과 동일하게 매 프레임마다 호출되고 연산해야 한다.
//만약에 60fps 로 돌아가는 그래픽 프로그램이라면 단지 5000개의 삼각형을 그리기 위해 (폴리곤이 고작 5천개)
//매 초마다 5,000 (5000 Polygons) *60 (60fps) *3 (매트릭스가 3개) = 900,000 번이나 연산을 해야한다
//때문에 여기 작성되는것들은 매우 효율적으로 작성되어야지만.. 성능 보장이 가능하다..

//픽셀 셰이더 -> 그리고자 하는 도형에 색상을 입힐 때를 위한 작은 프로그램이다. "화면에 보여지는" 모든 픽셀들에 대해 GPU 연산된다.
//색상을 입히고, 텍스처를 입히고, 광원 효과를 주고, 그 외에 여러 효과들이 픽셀에 반영되어야 할 때 모든것이 픽셀 셰이더 연산을 통해 진행된다.
//이 또한 GPU에 셀 수도 없을만큼 많이 호출되기 때문에 반드시 효율적으로 작성되어야 한다...

//HLSL -> 위에 작성한 내용들을 작성할 때 효율적으로 구현하기 위한 일종의 언어이다. C언어와 거의 동일하며
//1. 전역변수
//2. 타입 정의
//3. 정점 셰이더
//4. 픽셀 셰이더
//5. 기하 셰이더(Geometry Shader) 로 구성되어 있다.

//일단은 아주 간단하게만 작성해본다

//그리고, 결국 이것들은 전부 Graphics 클래스 안에 캡슐화되어 작성되며
//Model Class -> 도형에 대한 컨트롤 (기하학적 부분)
//Camera Class -> 카메라에 대한 컨트롤 (쉽게 말해 View Matrix 부분)
//ColorShader Class -> HLSL 셰이더를 사용하여 실제로 객체들을 그리고 컨트롤


////////////////////////
// GLOBALS
////////////////////////

cbuffer MatrixBuffer
{
	matrix worldMatrix;
	matrix viewMatrix;
	matrix projectionMatrix;
};


////////////////////////
// TYPEDEFS
////////////////////////

//여기서는 float4 타입을 사용하도록 하는데,
//float4 타입이란 float이 4개가 붙어 배열을 이루는 형식으로 작성되는 변수형이다.
//쉽게 말하면 RGBA 를 작성할 때 힘들게 코딩할 필요 없이
//float4(1.0f,1.0f,0.0f,1.0f) 이런식으로 4개를 연달아 작성할 수 있다는 것.
//포지션은 X,Y,Z,W 위치 벡터를 갖으므로 4개.

//정점 셰이더를 위한 인풋타입 정의
//아래는 모두 간단하게 Position, Color 만 넣어주었다.
struct VertexInputType
{
	float4 position : POSITION;
	//컬러 여러개를 주고 싶다면 COLOR0 이나 COLOR1 과 같이 변수 이름 끝에 숫자를 부여하여 사용하자
	float4 color : COLOR;
};

//픽셀 셰이더를 위한 인풋타입 정의
struct PixelInputType
{
	//정점 셰이더의 포지션과 구분을 주기 위하여 SV_POSITION 사용하였다.
	float4 position : SV_POSITION;
	float4 color : COLOR;
};


////////////////////////
// Vertex Shader
////////////////////////

//아래의 정점 셰이더는 정점 버퍼(Vertex Buffer)의 데이터를 처리하기 위해 GPU에 의해 호출된다.
//ColorVertexShader 정점 셰이더는 정점 버퍼의 모든 각 정점에 대해 호출된다.
//당연히 정점 셰이더 입력으로 들어오는 것은 Typedef 에서 정의한 자료구조와 동일해야 하며
//정점 셰이더 처리 결과는 다시 픽셀 셰이더로 보내져 색상을 입혀 표출되는 방식이다.
//결국 VertexInputType 와 동일한 자료구조로 들어온 데이터가 Vertex Shader 연산을 통해 PixelInputType 로 나와 다시 Pixel Shader 로 들어가야 한다.
//때문에 정점 셰이더는 그 출력값으로 PixelInputType 자료구조와 동일한 타입을 만들어내어야 한다.
//정점 셰이더에 입력된 정점들은 월드, 뷰, 직교 행렬과 곱셈 연산을 하게 되며, 이렇게 하면 3D로 표현되어있는 Vertex 들을 우리의 시야에 맞는
//2D 화면의 적절한 위치로 지정된다.
//여기서는 POSITION이 X,Y,Z,W 벡터까지 존재하지만 일단은 X,Y,Z 좌표만을 사용하기로 하고 W는 1.0으로 고정하도록 한다.

PixelInputType ColorVertexShader(VertexInputType input)
{
	PixelInputType output;

	//올바른 행렬 연산을 하기 위해 position 벡터를 w까지 있는 4성분으로 사용한다..
	input.position.w = 1.0f;

	//정점의 위치를 각각 월드, 뷰, 직교의 순으로 계산한다
	//여기서 mul은 행렬에 대한 곱연산
	output.position = mul(input.position, worldMatrix);
	output.position = mul(output.position, viewMatrix);
	output.position = mul(output.position, projectionMatrix);

	//그럼 지금, 최종 output은 3개의 연산을 거친 상태가 된다.
	//픽셀 셰이더에 사용하기 위해서 입력 색상을 잊지 말고 넘겨주자
	output.color = input.color;

	return output;
}